\documentclass[a4paper,12pt]{report}
\usepackage{graphicx}  % For including graphics
\usepackage{hyperref}  % For hyperlinks
\usepackage{listings}  % For code snippets
\usepackage{tocbibind} % For adding ToC to the table of contents
\usepackage{titlesec}  % For customizing titles
\usepackage[ngerman]{babel}
\usepackage{wasysym}
\usepackage{parskip}
\usepackage{bm}
\usepackage{xcolor}

\lstset{
    backgroundcolor=\color{black}, % Black background
    basicstyle=\ttfamily\small\color{white}, % Monospace font, white text
    frame=single, % Box around the code
    rulecolor=\color{gray}, % Border color
    breaklines=true, % Allow breaking long lines
    showstringspaces=false, % Don't show spaces as symbols
    xleftmargin=5pt, % Margin for padding
    xrightmargin=5pt
}


\usepackage{geometry}
\usepackage{booktabs}
\geometry{
    top=1in,
    left=1in,
    right=1in,
    bottom=1in
}


\titleformat{\chapter}[block]   % Set chapter format to block style (both on same line)
{\normalfont\huge\bfseries}     % Format for the chapter number and title
{\thechapter}                   % Shows the chapter number followed by a dot
{0.5em}                         % Space between the chapter number and title
{}                              % Formatting for the chapter title (leave empty)

\renewcommand{\contentsname}{Inhaltsverzeichnis}
\renewcommand{\listtablename}{Tabellenverzeichnis}
\renewcommand{\listfigurename}{Abbildungsverzeichnis}
\renewcommand{\lstlistlistingname}{Code-Ausschnitte}
\renewcommand{\abstractname}{Zusammenfassung}
\renewcommand{\chaptername}{Kapitel}

\begin{document}

% Title Page
    \begin{titlepage}
        \centering
        \textit{Berner Fachhochschule}\\[0.2em]
        \textit{BTI3031 Project 1}
        \vfill
        {\huge \textbf{AI-Aided Caches-n-Logs Monitoring-n-Wiping Daemon}}\\[4em]
        {\large Luca Scherer, Janic Scherer, Luca Ammann }\\[0.5em]
        \begin{tabular}{ll}
            \textbf{Betreuer:}\hspace{0.5em}Dr. Simon Kramer \\
        \end{tabular}

        \vfill
        \textit{\today}
    \end{titlepage}

% Abstract
    \begin{abstract}
        \ldots
    \end{abstract}

% Table of Contents
    \tableofcontents
    \listoftables
    \listoffigures
    \lstlistoflistings

% Main Content


    \chapter{Einleitung}


    \section{Ausgangssituation}

    \subsection{Problem}\label{subsec:problem}
    Cache- und Logdateien sind temporäre Dateien, die von Betriebssystemen und
    Anwendungen zur Speicherung von Zwischenständen, Nutzeraktivitäten und
    Systemereignissen erstellt werden.
    Viele Computerbenutzer sind sich nicht bewusst, welche Arten dieser Dateien auf ihrem
    Computer existieren und insbesondere, welche Applikationen diese lesen, schreiben,
    verändern oder löschen.
    Dazu sind sich Anwender nicht bewusst, welchen Zwecken
    diese Dateien dienen und welche möglicherweise vertrauliche Informationen enthalten,
    die für Dritte von Interesse sein könnten.
    Diese Unkenntnis kann zu Datenschutzrisiken
    und fehlender Kontrolle führen.

    \subsection{Chance}\label{subsec:chance}
    Durch das Angebot an generativen KI-Modellen, die – meist frei oder relativ günstig - im
    Internet zugänglich sind, lässt sich schnell Fachkenntnis zu solchen Dateien einholen.
    Betrachtet werden hierbei vor allem die Struktur (Syntax) und Bedeutung (Semantik) von Dateiinhalten.
    Des Weiteren lassen sich Schlüsse aus Änderungen, Löschungen und Neuerstellungen von Dateien ziehen.\footnote{Evalutation durch KI-Modell in Bezug auf die Bedeutung von Änderungen, Löschungen und Neuerstellungen nicht weiter realisiert, siehe Kapitel \nameref{sec:zukunftigearbeiten}.}
    Durch das automatisierte Abfragen dieser KI-Modelle in einer eigenen Anwendung,
    welche unter anderem Momentaufnahmen (sogenannte\ Snapshots) relevanter Dateipfaden und Metadaten speichert,
    sowie weitere Mehrwerte in Bezug auf die Nutzererfahrung realisiert, kann einem
    Benutzer auf einfache Art und Weise die Möglichkeit zur Kontrolle und Erleichterung dieses Umstandes
    geboten werden.

    \subsection{Antrag}\label{subsec:stakeholder}
    Das Projekt-Proposal TODO Querverweis umfasst einerseits die Entwicklung einer Software, welche die besagten Anforderungen erfüllt,
    andererseits das Ermitteln des Potentials aktueller KI-Modelle zur Lösung des genannten Problems.\\
    Einziger Stakeholder ist Simon Kramer als Betreuer und Auftraggeber.\\


    \section{Projektziel}\label{sec:projektziel}
    Es soll eine Anwendung entwickelt werden, welche die \textbf{Suche, Überwachung und Löschung von Cache- und Logdateien} ermöglicht.
    Dazu gehört das \textbf{Einholen von Einschätzungen eines KI-Modells}, welches die Dateien analysiert und bewertet.
    Die Applikation soll \textbf{plattformunabhängig}, \textbf{benutzerfreundlich} und mit der nötigen \textbf{Dokumentation} für den Benutzer (User-Manual u.a.) ausgestattet sein.
    \\Das AI-Modell wird nur abgefragt bzw.\ eingebunden und dessen Entwicklung und Betrieb
    wird vom Projekt abgegrenzt.
    Passend zu dieser Abgrenzung soll als Komponente des Berichts das Potential von KI-Modellen bzw.\ des eingesetzten KI-Modells zur Lösung des Problems evaluiert werden.


    \section{Prioritäten}
    Grundsätzlich soll ein fertiges Produkt, welches dem Benutzer einen Mehrwert bietet, im Vordergrund stehen.
    Gemäss Checkliste (via Mail von Simon Kramer am 26.09.2024):
    \begin{quote}
        Resultat- statt Prozess-Orientierung priorisieren:
        \\Fertiges Projekt anstreben (Prozesse, die unfertige Resultate produzieren, vermeiden)
        \\Programme sind bessere Modelle (Spezifikations- und Design-Endlosschlaufen vermeiden)
    \end{quote}

    Priorisiert sollen dabei in erster Linie Funktionalitäten eines MVP (Minimum Viable Product) sein, welche die Kernfunktionalität des Produkts sicherstellen.
    Dazu gehören vor allem die Suche und Überwachung von Dateien.
    Zur Überwachung gehört das Erstellen von Snapshots und das Vergleichen dieser, sowie das Einholen von Einschätzungen eines KI-Modells.
    Zudem werden alle Tätigkeiten, die dabei mitschwingen, wie Dokumentation, Tests und Codequalität, als wichtig erachtet.
    Zurückpriorisierte Funktioalitäten, sowie Erweiterungen werden im Kapitel \nameref{sec:zukunftigearbeiten} beschrieben.


    \chapter{Spezifikation}


    \section{Systemabgrenzung}

    \subsection{Systemumgebung (statisch)}

    \subsubsection{Systemübersicht}
    Der Hauptverwendungszweck des TraceSentry ist das Überwachen von Dateien in einem bestimmten Verzeichnis.
    Dabei liegt der Fokus auf Log- und Cache-Dateien, welche auf Änderungen in Form von Erstellung, Löschung oder Veränderung überprüft werden.
    Diese Überprüfung erfolgt in einem Hintergrundprozess (Daemon), welcher autonom und periodisch die Dateien überwacht.
    Die Resultate dieser Überwachung werden persistiert und dem Benutzer über eine Benutzerschnittstelle zugänglich gemacht.
    Der Benutzer hat zusätzlich die Möglichkeit, nach Dateien zu suchen, um sinnvolle Verzeichnisse für die Überwachung zu finden.
    Findet der Benutzer eine für ihn interessante Datei durch die Suche oder Überwachung, kann er eine Inspektion dieser Datei anfordern.
    Dabei analysiert ein KI-Modell die Datei und gibt eine Einschätzung ab, ob die Datei schädlich ist und wie damit umgegangen werden sollte.
    Über die Benutzerschnittstelle kann der Benutzer zusätzlich Dateien leeren oder löschen, insofern es für Ihn oder das KI-Modell sinnvoll erscheint.

    \subsubsection{Systemkontext}
    Der TraceSentry ist ein eigenständiges, plattformunabhängiges System, welches auf den gängigen Betriebssystemen (Windows, Linux, MacOS) lauffähig ist.
    Grundsätzlich wird dabei zwischen dem Daemon und der Benutzerschnittstelle unterschieden.
    \begin{itemize}
        \item \textbf{Daemon}: Der Daemon läuft im Hintergrund ohne direkte Benutzerinteraktion und übernimmt die grundlegende Geschäftslogik, wie die Interaktion mit dem Dateisystem.
        \item \textbf{Benutzerschnittstelle}: Die Benutzerschnittstelle ist die Schnittstelle zwischen dem Benutzer und dem Daemon und enthält keine Geschäftslogik.
    \end{itemize}

    TODO im Team definieren, ob Endscheidungen wie CLI, GPT etc. hier rein sollen oder in die Architektur.


    \clearpage

    \subsection{Prozessumgebung}

    \clearpage


    \section{Anforderungen}
    Die Anforderungen für den AI-Aided Caches-n-Logs Monitoring-n-Wiping Demon ergaben sich aus dem Projekt Proposal sowie einem initialen Termin mit Herr Kramer.

    \subsection{Funktionale Anforderungen}

    Alle funktionalen Anforderungen werden in Form von User Stories im Scrum Product Backlog geführt. Dieser wird laufend erweitert beziehungsweise konkretisiert. Eine User Story gilt erst als abgeschlossen, sobald alle dazugehörende Akzeptanzkriterien erfüllt sind. Folgende funktionale Anforderungen wurden definiert und in User Stories inkl. Akzeptanzkriterien abgebildet:
    \begin{itemize}
        \item Das System findet jegliche Log- oder Cache-Dateien, welche sich in einem angegebenen Verzeichnis befinden. Dabei werden auch alle Unterverzeichnisse berücksichtigt.
        \item Das System durchsucht periodisch angegebene Verzeichnisse inkl. Unterverzeichnisse nach Log- oder Cache-Dateien.
        \item Das System erstellt periodisch sogenannte Snapshots der gefundenen Dateien, um diese später miteinerander zu vergleichen.
        \item Das System identifiziert veränderte Dateien anhand der periodisch erstellten Snapshots.
        \item Das System kann den Verwendungszweck von angegebenen Dateien erkennen und nach folgenden Merkalen kategorisieren oder bewerten:
        \begin{itemize}
            \item Dateityp
            \item Verwendungszweck
            \item Schädlichkeit
            \item Leer- bzw. löschbar
        \end{itemize}
        \item Das System kann angegebene Dateien, nach einer Bestätigung des Benutzers leeren oder löschen.
    \end{itemize}
    TODO: Backlog einbinden/beschreiben

    \newpage

    \subsection{Grenz- und Vorbedingungen}
    Im Scrum Product Backlog werden nichtfunktionalen Anforderungen bzw. Grenz- oder Vorbedingungen nicht explizit als User Story geführt. Aus dem Projekt-Proposal und dem initialen Termin ergaben sich nachfolgende nichtfunktionale Anforderungen.
    Diese beeinflussten massgeblich die Architektur des Systems. Keine User Story darf eine oder mehrere nichtfunktionale Anforderungen verletzten, was durch die Definition of Done sichergestellt und laufend geprüft wird.

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.4cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID}           & NFR-001                                                                                            \\ \hline
            \textbf{Anforderung}  & Hintergrundprozess mit periodischem Task (deamon)                                                  \\ \hline
            \textbf{Beschreibung} & Das System muss einen Hintergrundprozess implementieren, der periodisch Aktionen durchführen kann. \\ \hline
            \textbf{Akzeptanzkriterien} &
            \begin{itemize}
                \item Nach dem Start des Prozesses, ist dieser für den Benutzer nicht mehr ersichtlich.
                \item Der Hintergrundprozess ist erweiterbar, sodass dieser periodisch und autonom Aktionen durchführen kann.
            \end{itemize}
            \\ \hline
        \end{tabular}
        \caption{Nichtfunktionale Anforderung NFR-001}\label{tab:nfr-1}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.4cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID}           & NFR-002                                                              \\ \hline
            \textbf{Anforderung}  & Benutzerschnittstelle via Konsole (CLI)                              \\ \hline
            \textbf{Beschreibung} & Mit dem laufenden deamon soll via Konsole interagiert werden können. \\ \hline
            \textbf{Akzeptanzkriterien} &
            \begin{itemize}
                \item Der deamon kann via CLI gestartet werden.
                \item Alle Konfigurationen und Aktionen des deamon sind via CLI verfügbar
            \end{itemize}
            \\ \hline
        \end{tabular}
        \caption{Nichtfunktionale Anforderung NFR-002}\label{tab:table4}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.4cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID}           & NFR-003                                                                 \\ \hline
            \textbf{Anforderung}  & Systemunabhängigkeit                                                    \\ \hline
            \textbf{Beschreibung} & Lauffähigkeit mit vollem Funktionsumfang auf gängigen Betriebssystemen. \\ \hline
            \textbf{Akzeptanzkriterien} &
            \begin{itemize}
                \item Hintergrundprozess sowie Konsolenschnittstelle sind auf allen gängigen Betriebssystemen lauffähig und mit vollem Funktionsumfang verwendbar.
                \item Neuimplementierte Features werden auf aktuellen Versionen von Windows, Linux (Ubuntu) und MacOS getestet.
            \end{itemize}
            \\ \hline
        \end{tabular}
        \caption{Nichtfunktionale Anforderung NFR-003}\label{tab:table5}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.4cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID}           & NFR-004                                        \\ \hline
            \textbf{Anforderung}  & Codequalität \& erweiterbare Architektur       \\ \hline
            \textbf{Beschreibung} & Minimaler, modularer und selbserklärender Code \\ \hline
            \textbf{Akzeptanzkriterien} &
            \begin{itemize}
                \item Die Architketur wird so aufgebaut, dass neue Features problemlos ergänzt werden können. (z.B. GUI)
                \item Tests gemäss Testkonzept.
                \item Statische Analysen zeigen keine schwerwiegenden verstösse gegen Linting-Regeln.
                \item Anwendungen von gängigen Design-Prinzipen vie SOLID, DRY, KISS etc.
                \item Für jede Codeerweiterung wird eine Codereview durch einen zweiten Entwickler vorgenommen.
            \end{itemize}
            \\ \hline
        \end{tabular}
        \caption{Nichtfunktionale Anforderung NFR-004}\label{tab:table6}
    \end{table}

    \clearpage

    \subsection{Testkonzept}

    \subsubsection{Ziel des Testkonzepts}
    \begin{itemize}
        \item Sicherstellen, dass das gesamte System stabil läuft und seine Hauptfunktionen zuverlässig verfügbar sind.
        \item Minimales Testing-Setup, das nur dort Unit-Tests verwendet, wo es Sinn ergibt (z. B. kritische Algorithmen), um den Entwicklungsaufwand gering zu halten.
        \item Fokus auf Integrationstests und funktionale Tests zur Überprüfung der gesamten Systemfunktionalität.
        \item Klare Definition, welche Tests während der Entwicklung (Teil einer User Story) umgesetzt werden sollen.
    \end{itemize}

    \subsubsection{Testarten und Testabdeckung}
    \begin{itemize}
        \item \textbf{Unit-Tests}: Nur für kritische, isolierbare Logiken wie:
        \begin{itemize}
            \item \textbf{Hash-Algorithmen}: Test der Konsistenz und Korrektheit, insbesondere, wenn Hashes fürs Verzeichnis Monitoring verwendet werden.
            \item \textbf{File-Suche}: Suchalgorithemen für Log- oder Cache-Dateien.
        \end{itemize}
        \item \textbf{Integrationstests}: Testen der Zusammenarbeit mehrerer Komponenten.
        \begin{itemize}
            \item \textbf{CLI-Befehle}: Überprüfen, dass die CLI-Kommandos (\texttt{run}, \texttt{search}) korrekt ausgeführt werden und die erwarteten Parameter validieren.
            \item \textbf{REST-HTTP-Anfragen}: Testen, ob alle HTTP-Schnittstellen korrekt reagieren. (Happy- sowie Exception-Paths)
        \end{itemize}
        \item \textbf{End-to-End Tests}: Fokus auf End-to-End-Szenarien zur Validierung der zentralen Funktionalität.
    \end{itemize}

    \subsubsection{Test-Setup und -Konfiguration}
    \begin{itemize}
        \item \textbf{Mocking von Ressourcen}: Verwenden von Mocks für Datenbank- und Dateisystemzugriffe in den Unit-Tests, um sie isoliert zu halten.
        \item \textbf{Testumgebung}: Erstellen einer dedizierten Test-DB und eines Testverzeichnisses.
        \item \textbf{Automatisierte Testausführung}: Integration der Tests in die CI/CD-Pipeline, um sicherzustellen, dass das System stabil bleibt.
    \end{itemize}

    \clearpage


    \section{Usability}\label{sec:usability}

    \subsection{Persona}\label{subsec:persona}
    Nachfolgend handelt es sich um eine fiktive Person, die als Repräsentation eines typischen Benutzers des Systems dient.

    \subsubsection{Thomas}

    \begin{figure}[h]
        \centering
        \includegraphics[width=0.6\textwidth]{assets/persona1}
        \caption{Thomas \footnote}
        \label{fig:persona-1}
    \end{figure}

    Thomas ist ein 35-Jähriger Berufsschullehrer, der Informatiker und Elektroniker unterrichtet.
    Für seine Schüler unterrichtet er unter anderem auch
    Systemadministration und IT-Sicherheit.
    Thomas ist sehr interessiert an neuen Technologien und probiert gerne neue Software aus.
    Daher stellt er sich die Frage, warum so viele Log- und Cache-Dateien auf seinem Rechner sind, ob diese alle
    ihre Daseinsberechtigung haben und auch ob das Lesen und Schreiben dieser Dateien nicht ein Sicherheitsrisiko
    darstellt.
    Thomas ist ein sehr erfahrener Benutzer und hat keine Probleme mit der Kommandozeile.

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.4cm}
        \begin{tabular}{|p{2.5cm}|p{7cm}|}
            \hline
            \textbf Aufgaben    & KnowHow stärken (in Bezug auf seine Lehrtätigkeiten)                      \\
            \hline
            \textbf Ziele       & Veränderungen beobachten können und diese überprüfen lassen               \\
            \hline
            \textbf Wünsche     & Intuitive Benutzerschnittstelle und teilweise Automatisierung             \\
            \hline
            \textbf Hindernisse & Trotz Erfahrung in der Informatik, sind teilweise Wissenslücken vorhanden \\
            \hline
        \end{tabular}
        \label{tab:table7}
    \end{table}

    \footnotetext{\url{https://www.pexels.com/de-de/foto/mann-arbeiten-tippen-pc-16129724/}.}


    \newpage

    \subsection{Storyboard}
    In diesem Abschnitt wird beschrieben, wie ein Nutzer mit den verschiedenen Funktionen der Software
    interagieren kann.
    Dafür haben wir folgend eine sinnvolle Abfolge zusammengestellt, wie ein Nutzer
    unsere Software in einem realen Anwendungsfall verwenden könnte.

    \begin{enumerate}
        \item \textbf{Dateien suchen}\\
        Der Nutzer hat kürzlich in seinem Task-Manager ein Programm entdeckt, das komischerweise
        ziemlich viel Speicher braucht.
        Also verwendet er unseren search-Befehl mit dem Pfad auf die Installation von diesem Programm
        und ihm werden die in diesem Verzeichnis gefundenen Cache- sowie Log-Dateien aufgelistet:
        \begin{verbatim}
internal/test.log
internal/cache.json
        \end{verbatim}

        \item \textbf{Dateien überwachen}\\
        Nun möchte der Nutzer dieses Verzeichnis \texttt{/internal} innnerhalb des Programmverzeichnisses genauer überwachen.
        Also fügt er diesen Pfad mit dem monitor-Befehl hinzu und schon wird dieses Verzeichnis vom TraceSentry stündlich überwacht.

        \item \textbf{Snapshots vergleichen}\\
        Nach einigen Stunden möchte nun der Nutzer wissen was in diesem überwachten Verzeichnis passiert ist.
        Dafür nutzt er den snapshot compare-Befehl, um alle Zustände des Verzeichnisses vom aktuellen Zeitpunkt bis zum Start der Überwachung vergleichen zu können.
        Das System gibt ihm eine entsprechende Ausgabe:
        \begin{verbatim}
Vergleich vom Verzeichnis /internal
vom Zeitpunkt 01.12.2024 15:00:00 bis zum Zeitpunkt 01.12.2024 22:00:00:

test.log CHANGED 7-times
        \end{verbatim}

        \item \textbf{KI-Abfrage für eine Datei}\\
        Nun möchte der Nutzer natürlich wissen, wofür diese test.log Datei ist, wenn sich diese jede Stunden ändert.
        Also nutzt er den inspect-Befehl, um die angebundene KI abzufragen, wofür diese Datei genau ist, ob sie ein Sicherheitsrisiko darstellt
        und ob er die Datei evtl. leeren oder sogar löschen kann.
        Daraus kommt dann eine standardisierte Ausgabe von der KI:
        \begin{verbatim}
Die Datei ist unbekannt für dieses Programm und deswegen potenziell
schädlich, also empfehle ich es zu leeren.
        \end{verbatim}

        \item \textbf{Datei leeren oder löschen}\\
        Zum Schluss kann der Nutzer dann selbst entscheiden was er mit dieser Information anfangen möchte.
        In diesem Fall möchte er dem Ratschlag der KI folgen und die Datei leeren.
        Also nutzt er den wipe-Befehl mit dem Pfad der test.log Datei und das System leert die Datei wie gewünscht.
    \end{enumerate}

    \newpage

    \subsection{UX-Prototyping}
    Da das System ausschließlich über ein Command-Line-Interface (CLI) verfügt,
    wird die Dokumentation dieser Schnittstelle im nachfolgenden Kapitel \hyperref[sec:user-manual]{Benutzerhandbuch}
    umfassend behandelt.
    Diese Dokumentation wurde im Rahmen eines iterativen und agilen Entwicklungsprozesses
    kontinuierlich während der Implementierung der einzelnen Befehle erstellt.
    Sie enthält eine detaillierte Beschreibung aller verfügbaren Befehle, einschließlich ihrer Syntax, Parameter und Anwendungsbeispiele.
    Darüber hinaus werden mögliche Systemantworten im Kontext verschiedener Szenarien erläutert,
    um eine praxisnahe Nutzung zu gewährleisten.


    \chapter{Implementierung}


    \section{Architektur}

    \subsection{Technische Variantenentscheide}

    \subsubsection{Architekturentscheid}
    In diesem Abschnitt werden die Überlegungen zur Architektur des Systems dargestellt.
    Es wird erläutert, welche Varianten in Betracht gezogen wurden, welche Entscheidung getroffen wurde und welche Gründe dazu geführt haben.

    \paragraph{1. Datenbankauswahl}\mbox{}\\
    Eine zentrale Anforderung besteht darin, dass Pfad-Analysen zu einem späteren Zeitpunkt miteinander verglichen werden können.
    Daraus ergibt sich die Notwendigkeit, eine Datenbank (DBMS) zu integrieren.
    Im Folgenden werden die in Betracht gezogenen Varianten analysiert.

    \paragraph{1.1 In-Memory-Datenbank}\mbox{}\\
    Bei dieser Variante wird die Datenbank während der Laufzeit des Programms im Arbeitsspeicher initialisiert und beim Beenden des Programms wieder gelöscht.
    Dies bedeutet, dass die Datenbank nur temporär verfügbar ist und den Hauptspeicher des Systems nutzt.

    \paragraph{Vorteile}
    \begin{itemize}
        \item Sehr hohe Zugriffsgeschwindigkeit, da die Daten im Arbeitsspeicher gehalten werden.
        \item Einfache Integration ohne dauerhaften Speicherbedarf.
    \end{itemize}

    \paragraph{Nachteile}
    \begin{itemize}
        \item Keine Persistenz der Daten über die Laufzeit hinaus.
        \item Erhöhter Speicherbedarf während der Laufzeit des Programms.
    \end{itemize}

    \paragraph{Fazit}
    Diese Variante wurde ausgeschlossen, da die Persistenz der Daten eine essentielle Anforderung darstellt.
    Eine In-Memory-Datenbank würde nicht ermöglichen, dass Analysen auch nach einem Neustart des Systems verfügbar bleiben.

    \paragraph{1.2 Eingebettete Datenbank}\mbox{}\\
    Eine eingebettete Datenbank wird als Ressource des Programms bereitgestellt und bleibt persistent, solange die entsprechenden Dateien im Programmverzeichnis nicht gelöscht werden.
    Sie bietet eine leichtgewichtige Lösung für kleinere Anwendungen.

    \paragraph{Vorteile}
    \begin{itemize}
        \item Keine Notwendigkeit für externe Infrastruktur, wodurch die Einrichtung vereinfacht wird.
        \item Volle Offline-Funktionalität, da keine Verbindung zu externen Diensten erforderlich ist.
        \item Hohe Performance durch direkte Anbindung an das Programm.
    \end{itemize}

    \paragraph{Nachteile}
    \begin{itemize}
        \item Risiko eines Datenverlusts bei Fehlern oder Ausfällen des Anwendersystems.
        \item Eingeschränkte Skalierbarkeit bei wachsenden Datenmengen.
    \end{itemize}

    \paragraph{Fazit}
    Die eingebettete Datenbank wurde als die am besten geeignete Option identifiziert.
    Sie erfüllt die Anforderungen eines kleinen Systems ohne die Notwendigkeit zusätzlicher Infrastruktur und ermöglicht eine einfache und schnelle Einrichtung.
    Da das System hauptsächlich offline betrieben werden soll, bietet diese Lösung eine optimale Balance zwischen Effizienz und Funktionalität.
    Die Verantwortung für die Datenbank wird dabei auf den Anwender übertragen, was den Verwaltungsaufwand reduziert.

    \paragraph{1.3 Remote-Datenbank}\mbox{}\\
    Bei dieser Variante wird die Datenbank auf einem externen System betrieben und über das Netzwerk vom Abnehmer aus angesprochen.
    Die Daten bleiben persistent, solange sie auf dem externen System nicht gelöscht werden und dieses ordnungsgemäß funktioniert.

    \paragraph{Vorteile}
    \begin{itemize}
        \item Höhere Datensicherheit, da die Daten auf einem separaten System gespeichert werden können, welches durch Backup-Strategien abgesichert ist.
        \item Größere Speicherkapazität, da die Skalierung auf leistungsfähige Server oder Cloud-Dienste möglich ist.
    \end{itemize}

    \paragraph{Nachteile}
    \begin{itemize}
        \item Abhängigkeit von einer stabilen Netzwerkverbindung, wodurch das System ohne Internet nicht verfügbar ist.
        \item Zusätzlicher Aufwand und Kosten durch die Einrichtung und Wartung der externen Infrastruktur.
    \end{itemize}

    \paragraph{Fazit}
    Die Remote-Datenbank wurde als ungeeignet für diesen Anwendungsfall bewertet.
    Die Vorteile wie erhöhte Datensicherheit und Skalierbarkeit sind für das derzeitige System nicht notwendig, da es sich um eine kleine, lokal betriebene Anwendung handelt.
    Die zusätzlichen Anforderungen an Infrastruktur und die Abhängigkeit von einer Netzwerkverbindung stellen einen unverhältnismäßigen Mehraufwand dar, der den Nutzen nicht rechtfertigt.

    \paragraph{2. Schnittstelle CLI $\leftrightarrow$ Daemon}\mbox{}\\
    Für die Kommunikation zwischen der CLI (Command Line Interface) und dem Daemon ist eine geeignete Schnittstelle erforderlich, um Anweisungen des Anwenders effizient und zuverlässig zu übertragen.
    Im Folgenden werden die in Betracht gezogenen Varianten analysiert.

    \paragraph{2.1 REST-Schnittstelle}\mbox{}\\
    Die REST-Schnittstelle ermöglicht den Austausch von Ressourcen zwischen Client und Server über das HTTP-Protokoll.
    Der Austausch erfolgt im Rahmen definierter Formate (Content-Types) und kann über das Netzwerk abgewickelt werden.

    \paragraph{Vorteile}
    \begin{itemize}
        \item Standardisierte Schnittstelle, die durch zahlreiche Frameworks unterstützt wird.
        \item Hohe Robustheit, da REST auf etablierten HTTP-Standards basiert.
        \item Ermöglicht die Ausführung von CLI und Daemon auf getrennten Systemen, was eine flexible Architektur fördert.
    \end{itemize}

    \paragraph{Nachteile}
    \begin{itemize}
        \item Erfordert die Implementierung eines Webservices, was zusätzlichen Entwicklungsaufwand bedeutet.
    \end{itemize}

    \paragraph{Fazit}
    Die REST-Schnittstelle wurde als die bevorzugte Option gewählt, da sie eine klare und standardisierte technische Kommunikation ermöglicht.
    Sie ist stabil, flexibel und erweiterbar, was besonders wichtig für den langfristigen Betrieb und mögliche zukünftige Anforderungen, wie die Systemtrennung von CLI und Daemon, ist.
    Zudem ist die Implementierung dank vorhandener Frameworks verhältnismäßig einfach und effizient.

    \paragraph{2.2 Inter-Prozess-Kommunikation (IPC)}\mbox{}\\
    Diese Variante nutzt einen gemeinsamen Speicherbereich, beispielsweise ein geteiltes Verzeichnis, um Dateien für die Kommunikation zwischen CLI und Daemon auszutauschen.
    Die CLI schreibt Anweisungen in Dateien, die der Daemon anschließend ausliest und verarbeitet.

    \paragraph{Vorteile}
    \begin{itemize}
        \item Einfach zu implementieren bei lokalem Einsatz auf demselben Rechner.
        \item Keine Netzwerkkonfiguration erforderlich.
    \end{itemize}

    \paragraph{Nachteile}
    \begin{itemize}
        \item Erfordert die Definition eines eigenen Dateiformats und entsprechender Parser.
        \item CLI und Daemon müssen auf demselben System laufen, was die Flexibilität einschränkt.
        \item Es besteht das Risiko von Konflikten beim gleichzeitigen Schreiben und Lesen von Dateien, was zusätzliche Synchronisationsmechanismen erfordert.
    \end{itemize}

    \paragraph{Fazit}
    Diese Option wurde aufgrund ihrer mangelnden Flexibilität und Erweiterbarkeit ausgeschlossen.
    Insbesondere die lokale Bindung zwischen CLI und Daemon sowie die fehlende Standardisierung und Robustheit der Kommunikation sprechen gegen diese Variante.
    Für zukünftige Anforderungen, wie die Kommunikation über ein Netzwerk, wäre sie ungeeignet.

    \paragraph{2.3 Netzwerk-Sockets}\mbox{}\\
    Netzwerk-Sockets ermöglichen die Kommunikation zwischen Prozessen durch das Senden und Empfangen binärer Daten über spezifische Ports.
    Diese Methode kann sowohl lokal als auch über das Netzwerk verwendet werden.

    \paragraph{Vorteile}
    \begin{itemize}
        \item Einfach zu verwenden und flexibel steuerbar.
        \item Unterstützt die Kommunikation zwischen CLI und Daemon auf getrennten Systemen über das Netzwerk.
        \item In Java durch das \texttt{java.net}-Package nativ verfügbar.
    \end{itemize}

    \paragraph{Nachteile}
    \begin{itemize}
        \item Nachrichtenformat muss individuell definiert und implementiert werden, was zusätzlichen Entwicklungsaufwand verursacht.
    \end{itemize}

    \paragraph{Fazit}
    Obwohl Netzwerk-Sockets eine flexible und leistungsfähige Lösung darstellen, wurde diese Variante zugunsten der REST-Schnittstelle verworfen.
    Die REST-Implementierung erscheint aufgrund ihrer Standardisierung und einfacher Handhabung im Kontext des Projekts effizienter.
    Zudem entfällt der Aufwand für die Definition und das Parsen eines eigenen Nachrichtenformats.
    \clearpage

    \subsubsection{Technologieentscheid}
    In diesem Abschnitt werden die Überlegungen zu den Technologien für die verschiedenen Systemkomponenten dargestellt.
    Basierend auf einer Analyse der Vor- und Nachteile wurde eine Entscheidung für die geeignetsten Technologien getroffen.

    \paragraph{1. Datenbank}\mbox{}\\
    Die Auswahl einer passenden Datenbank ist entscheidend für die Persistenz und Verarbeitung der Anwendungsdaten.
    Dabei wurde zunächst die grundsätzliche Entscheidung zwischen \textbf{NoSQL} und \textbf{SQL} analysiert.

    \paragraph{1.1 NoSQL}\mbox{}\\
    NoSQL-Datenbanken verwenden flexible Datenmodelle wie Dokumente, Key-Value oder Graphen und sind für hohe Skalierbarkeit sowie große Datenmengen ausgelegt.

    \paragraph{Vorteile}
    \begin{itemize}
        \item Hohe Flexibilität: Anpassbare Datenstrukturen ohne festes Schema.
        \item Einfache horizontale Skalierbarkeit: Gut geeignet für große Datenmengen.
        \item Spezialisierung: Verschiedene Modelle für spezifische Anwendungsfälle.
    \end{itemize}

    \paragraph{Nachteile}
    \begin{itemize}
        \item Fehlende Standardisierung: Unterschiedliche Abfragesprachen und Protokolle je nach Implementierung.
        \item Eingeschränkte Transaktionssicherheit: ACID-Eigenschaften werden häufig zugunsten der Performance vernachlässigt.
        \item Höhere Komplexität: Abfragen sind weniger intuitiv als in SQL-basierten Systemen.
    \end{itemize}

    \paragraph{Fazit}
    Die Vorteile von NoSQL-Datenbanken bringen für dieses Projekt keinen nennenswerten Mehrwert, da dieser Anwendungsfall keine besonderen Anforderungen an Skalierbarkeit oder unstrukturierte Daten stellt.
    Auch aufgrund mangelnder Erfahrung im Team mit NoSQL-Systemen wurde diese Option verworfen.

    \paragraph{1.2 SQL}\mbox{}\\
    SQL-Datenbanken basieren auf einem relationalen Modell mit festen Schemata.
    Sie verwenden die standardisierte Abfragesprache SQL und sind besonders geeignet für datenintensive Anwendungen mit hohen Anforderungen an Konsistenz.

    \paragraph{Vorteile}
    \begin{itemize}
        \item Standardisierung: Einheitliche Abfragesprache und breite Unterstützung.
        \item Datenkonsistenz: Verlässliche Transaktionen dank ACID-Eigenschaften.
        \item Leistungsstarke Abfragemöglichkeiten: Geeignet für komplexe relationale Analysen.
    \end{itemize}

    \paragraph{Nachteile}
    \begin{itemize}
        \item Feste Schemata: Weniger flexibel bei Änderungen in der Datenstruktur.
        \item Begrenzte horizontale Skalierbarkeit: Schwieriger als bei NoSQL umzusetzen.
        \item Suboptimale Performance bei großen unstrukturierten Datenmengen.
    \end{itemize}

    \paragraph{Fazit}
    Die Wahl fiel auf SQL-Datenbanken, da diese den Anforderungen an Konsistenz und relationale Abfragemöglichkeiten optimal entsprechen.
    Alle Teammitglieder verfügen über umfassende Erfahrung mit SQL, was die Implementierung erleichtert.
    Die Nachteile, wie begrenzte Skalierbarkeit, sind für dieses Projekt vernachlässigbar.

    \paragraph{1.2.1 H2}\mbox{}\\
    H2 ist eine leichtgewichtige, Java-basierte relationale Datenbank, die sowohl eingebettet als auch im Servermodus betrieben werden kann.

    \paragraph{Vorteile}
    \begin{itemize}
        \item Integration in Java: Optimiert für Java-Anwendungen und unterstützt JDBC.
        \item Vielseitigkeit: Kann als eingebettete oder serverbasierte Datenbank eingesetzt werden.
        \item Erweiterte Funktionen: Unterstützung für in-memory-Datenbanken und Multi-Threaded-Betrieb.
    \end{itemize}

    \paragraph{Nachteile}
    \begin{itemize}
        \item Eingeschränkte Eignung für große Workloads: Nicht für datenintensive Anwendungen ausgelegt.
        \item Java-Abhängigkeit: Begrenzte Unterstützung in nicht-Java-Umgebungen.
        \item Persistenzprobleme: Daten können im Speicher verloren gehen, wenn nicht korrekt gesichert.
    \end{itemize}

    \paragraph{Fazit}
    H2 wurde ausgeschlossen, da es nicht für große Datenmengen ausgelegt ist und eine zu starke Abhängigkeit von Java besteht.
    Zudem erfüllt SQLite unsere Anforderungen besser.

    \paragraph{1.2.2 SQLite}\mbox{}\\
    SQLite ist eine serverlose, eingebettete relationale Datenbank, die Daten in einer einzigen Datei speichert und keine separate Konfiguration erfordert.

    \paragraph{Vorteile}
    \begin{itemize}
        \item Einfachheit: Keine zusätzliche Konfiguration oder separate Server erforderlich.
        \item Portabilität: Daten sind in einer Datei gespeichert, was die Migration erleichtert.
        \item Ressourcenschonend: Geringe Anforderungen an Speicher und Rechenleistung.
    \end{itemize}

    \paragraph{Nachteile}
    \begin{itemize}
        \item Begrenzte Skalierbarkeit: Nicht geeignet für Anwendungen mit hohem gleichzeitigen Datenzugriff.
        \item Eingeschränkte Funktionalität: Unterstützt nicht alle erweiterten SQL-Funktionen.
        \item Performance-Einbußen bei großen Datenmengen.
    \end{itemize}

    \paragraph{Fazit}
    SQLite wurde ausgewählt, da es unseren Anforderungen an Einfachheit und lokale Persistenz optimal entspricht.
    Die Nachteile sind für dieses Projekt vernachlässigbar.

    \paragraph{2. CLI/Daemon}\mbox{}\\
    Für die Entwicklung von CLI und Daemon wurde eine einheitliche Technologie gewählt, um den Entwicklungsaufwand zu reduzieren und die Wiederverwendbarkeit von Code zu fördern.

    \paragraph{2.1 Java}\mbox{}\\
    Java ist eine objektorientierte, plattformunabhängige Sprache, die sich durch Stabilität, Performance und breite Unterstützung auszeichnet.

    \paragraph{Vorteile}
    \begin{itemize}
        \item Hohe Performance: Geeignet für rechenintensive Anwendungen.
        \item Strukturierte Entwicklung: Klare Organisation und starke Typisierung fördern die Wartbarkeit.
        \item Integration: Gute Unterstützung für APIs und Frameworks wie Spring.
    \end{itemize}

    \paragraph{Nachteile}
    \begin{itemize}
        \item Höhere Komplexität: Erfordert mehr Boilerplate-Code und strikte Typisierung.
        \item Eingeschränkte Bibliotheken für KI: Weniger umfangreiche KI- und ML-Bibliotheken im Vergleich zu Python.
        \item Langsamere Prototypenentwicklung: Weniger geeignet für schnelle Iterationen.
    \end{itemize}

    \paragraph{Fazit}
    Java wurde gewählt, da alle Teammitglieder bereits über umfassende Erfahrung verfügen und die Sprache eine hohe Performanz und Stabilität bietet.
    Die Einschränkungen hinsichtlich KI-Integration waren für dieses Projekt zu wenig gewichtig.
    Frameworks wie Spring erleichtern zudem die Implementierung der CLI/Daemon-Architektur.

    \paragraph{2.2 Python}\mbox{}\\
    Python ist eine einfach zu erlernende, vielseitige Programmiersprache, die insbesondere für datengetriebene Anwendungen und schnelle Entwicklung geeignet ist.

    \paragraph{Vorteile}
    \begin{itemize}
        \item Einfache Syntax: Kürzere Entwicklungszeit und schnelle Einarbeitung.
        \item Starke KI-Unterstützung: Umfangreiche Bibliotheken wie \texttt{transformers} und \texttt{torch}.
        \item Flexibilität: Besonders geeignet für schnelle Iterationen und Skripte.
    \end{itemize}

    \paragraph{Nachteile}
    \begin{itemize}
        \item Geringere Performance: Nicht ideal für rechenintensive Anwendungen.
        \item Dynamische Typisierung: Kann bei großen Projekten zu Wartungsproblemen führen.
        \item Distributionsprobleme: Erfordert oft spezielle Umgebungen oder Pakete.
    \end{itemize}

    \paragraph{Fazit}
    Obwohl Python starke Vorteile in Bezug auf KI-Bibliotheken bietet, wurde diese Option aufgrund der geringeren Performanz und fehlenden Erfahrung im Team verworfen.
    Java erwies sich als besser geeignet für unsere Anforderungen.
    \clearpage

    \subsection{Lösungsarchitektur}\label{subsec:loesungsarchitektur}

    \begin{figure}[h]
        \centering
        \includegraphics[width=1\textwidth]{assets/comp-diag-tracesentry-v3}
        \caption{UML Komponentendiagramm}
        \label{fig:comp-diag}
        \vspace{2em}
    \end{figure}

    \textnormal{Das System besteht aus zwei Hauptkomponenten, welche als eigene Laufzeiteinheiten ausgeführt werden.
    Die CLI wird ad hoc gestartet und dient als Benutzerschnittstelle.
    Der Daemon läuft nach dem Start im Hintergrund und führt periodisch Operationen aus. Ausserdem stellt er der
    CLI eine REST-Schnittstelle zur Verfügung.
    Ein Datenbanksystem speichert die Applikationsdaten.\\
    Die im Diagramm dargestellten Subkomponenten kapseln Funktionalitäten und sind in der Regel in eigenen Klassen implementiert.
    Es können mehrere Instanzen dieser Subkomponenten implementiert werden und nach fachlichen Aspekten, sogenannten Domänen, aufgeteilt werden.
    \\Am Beispiel einer Snapshot-Domäne würden dann im Backend ein Snapshot-(Rest)-Controller, ein Snapshot-(Domain)-Service und ein Snapshot-Repository existieren.
    D.h. eine Kapselung findet in technischer und fachlicher Hinsicht statt. Eine komplette Abkapselung ist jedoch in der Praxis schwierig und soll lediglich angestrebt werden.\\
    }
    \newpage

    \subsubsection{Shell}
    Die Shell stellt eine Kommandozeilen-Benutzerschnittstelle zur Verfügung.
    Sie kapselt die Definition von Kommandos und deren Parameter.
    Ausserdem übernimmt sie das Parsen der Benutzereingaben, clientseitige Validierung sowie Exception-Handling.

    \subsubsection{Rest Adapter}
    Der Rest Adapter kapselt Funktionen zur Interaktion mit der REST-Schnittstelle.

    \subsubsection{Rest Controller}
    Der Rest Controller implementiert die Endpunkte der REST-Schnittstelle gemäss API-Spezifikation. TODO Querverweis

    \subsubsection{Domain Service}
    Der Domain Service implementiert die Applikations- bzw.\ Geschäftslogik.
    Dazu gehört Serverseitige Validierung, Datenverarbeitung und -persistierung.

    \subsubsection{Operations Scheduler}
    Der Monitoring Scheduler führt periodisch Operationen aus.

    \subsubsection{Repository}
    Das Repository stellt den Zugang zur Persistenzschicht zur Verfügung.
    Dabei handelt es sich um Create, Read, Update, Delete (CRUD) Operationen in Form von Datenbankqueries.

    \subsubsection{Technologien}
    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.4cm}
        \begin{tabular}{|p{5.5cm}|p{5cm}|}
            \hline
            & \textbf{Technologien (primär)} \\
            \hline
            \textbf{Shell}                & Java, Spring (Shell)           \\
            \hline
            \textbf{Rest Adapter}         & Java, Spring (Web)             \\
            \hline
            \textbf{Rest Controller}      & Java, Spring (Web)             \\
            \hline
            \textbf{Domain Service}       & Java, Spring                   \\
            \hline
            \textbf{Operations Scheduler} & Java, Spring                   \\
            \hline
            \textbf{Repository}           & Java, Spring (Data)            \\
            \hline
            \textbf{Database}    & SQLite                         \\
            \hline
        \end{tabular}
        \caption{Technologien der Komponenten}\label{tab:table}
    \end{table}

    \clearpage

    \subsection{Realisierung}\label{subsec:realisierung}

    \subsubsection{Frontend}
    \clearpage

    \subsubsection{Backend}
    büsnei Logik & Komplexität
    taskscheduler
    \clearpage

    \subsubsection{Datenbank}
    \clearpage

    \subsubsection{REST-Schnittstelle}
    \clearpage

    \subsubsection{KI-Anbindung}
    \clearpage

    \subsubsection{Performanz und Optimierung}

    \textbf{Komplexität}

    Unser System ist von Grund auf auf Effizienz und Performanz ausgelegt, der Hashbaum als zentrale Datenstruktur ermöglicht dies.
    Die Datenmenge mit der ein Benutzer arbeitet, kann sehr gross werden, daher ist es wichtig, dass die Skalierbarkeit des Systems gewährleistet ist.
    Eine Analyse der Komplexität der verschiedenen Operationen ist also angebracht.
    \\
    Jeder Ordner und jede Datei wird als Knoten im Hashbaum repräsentiert.
    Die Wurzel des Hashbaums repräsentiert den zu überwachenden Pfad.
    Dateien sind stets Blätter.\newline
    Sei $n$ die Anzahl der Knoten im Verzeichnis des zu überwachenden Pfades.

    \textbf{Bau}

    Der Baualgorithmus besucht rekursiv alle Dateien und Ordner im zu überwachenden Pfad,
    was einer Komplexität von $O(n)$ für das Traversieren entspricht.
    Das Hashen eines Ordners mit $k$ Kindern setzt eine Iteration über alle Kinder voraus, was einer Komplexität von $O(k)$ entspricht.
    Das Hashen eines Blattes (Datei) ist abhängig von der Grösse $s$ der Datei und hat eine Komplexität von $O(s)$.
    \\\\
    Die Gesamtkomplexität des Bauens des Hashbaums beträgt also \boldsymbol{$O(n * s)$}
    Hier ist $s$ die durchschnittliche Dateigrösse. $k$ ist implizit in $n$ enthalten.

    \textbf{Linearisierung}

    Es gibt Fälle, in denen der Hashbaum linearisiert wird, um z.B.\ die Java Stream API zu verwenden oder direkt alle Knoten miteinander zu persisitieren.
    Es werden für alle Knoten die Referenzen in einer Liste gespeichert, was einer Komplexität von  \boldsymbol{$O(n)$} entspricht.

    \textbf{Caching}

    In den folgenden zwei Szenarien wurde geprüft, ob die Implementierung eines Caching-Mechanismus sinnvoll ist.
    Basierend auf den analysierten Aspekten wurde jedoch entschieden, darauf zu verzichten.
    Die Entscheidungsgrundlage wird im Folgenden erläutert:

    \begin{enumerate}
        \item Für jeden \texttt{MonitoredPath} könnte der zuletzt erzeugte Merkle-Tree zwischengespeichert werden, um diesen beim nächsten Snapshot direkt mit dem neuen Baum vergleichen zu können,
        ohne ihn erneut aus der Datenbank laden zu müssen.
        \begin{itemize}
            \item Ein Caching-Ansatz ist nur dann sinnvoll, wenn dieselben Daten mehrfach genutzt werden.
            Da jedoch der Merkle-Tree des letzten Snapshots lediglich einmal (beim Vergleich mit dem neuen Baum) verwendet wird, ergibt sich hieraus kein signifikanter Nutzen.
            \item Der Leistungsgewinn durch Caching wäre im Vergleich zum Laden aus der Datenbank marginal.
            Die Datenbank ist lokal angebunden, und die Abfrage weist eine geringe Komplexität auf, sodass ein effizienter Zugriff bereits gewährleistet ist.
        \end{itemize}
        \item Für jeden \texttt{MonitoredPath} könnte eine geordnete Liste der Änderungen jedes Snapshots im Speicher gehalten werden, um diese direkt zurückgeben zu können,
        ohne auf die Datenbank zugreifen zu müssen.
        \begin{itemize}
            \item Auch in diesem Szenario wird keine nennenswerte Steigerung der Performance erwartet.
            Selbst wenn die Daten bereits im Speicher verfügbar wären, erfordert die Erstellung der zusammengefassten Antwort zusätzliche Logik.
            Diese kann ebenso effizient durch eine Abfrage auf die lokale Datenbank umgesetzt werden, wodurch sich kein signifikanter Vorteil ergibt.
        \end{itemize}
    \end{enumerate}

    \textbf{Indexing}

    Die Entscheidung über die Sinnhaftigkeit eines SQL-Indexes für bestimmte Attribute der Datenbank basierte auf den folgenden Kriterien:

    \textit{Index sinnvoll:}
    \begin{itemize}
        \item Das Attribut weist eine hohe Kardinalität (viele unterschiedliche Werte) auf.
        \item Das Attribut enthält wenige oder keine Null-Werte.
        \item Das Attribut wird häufig in SQL \texttt{WHERE/JOIN}-Klauseln verwendet.
    \end{itemize}

    \textit{Index nicht sinnvoll:}
    \begin{itemize}
        \item Die Tabelle ist von geringer Größe.
        \item Das Attribut wird häufig manipuliert.
    \end{itemize}

    Auf Basis dieser Überlegungen wurden die folgenden Attribute zur Indexierung ausgewählt:
    \begin{itemize}
        \item \texttt{snapshot\_node.snapshot\_id}
        \item \texttt{snapshot\_node.has\_changed}
        \item \texttt{snapshot\_node.deleted\_in\_next\_snapshot}
    \end{itemize}

    \clearpage


    \section{Prozesse}
    \url{https://www.ganttlab.com} \\
    \url{https://www.hermes.admin.ch/de/projektmanagement/verstehen/ubersicht-hermes/methodenubersicht.html}


    \chapter{Evaluation und Tests}


    \section{Manuelle End-2-End Tests}
    Wie durch das Testkonzept definiert, wurden die End-2-End Tests mehrmals manuell durchgeführt.

    \subsection{Testfälle}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID}                  & E2E-001                                    \\ \hline
            \textbf{Beschreibung}        & Daemon starten und stoppen                 \\ \hline
            \textbf{Vorbedingungen} &
            \begin{itemize}
                \item Daemon läuft nicht
            \end{itemize} \\ \hline
            \textbf{Ablauf} &
            \begin{enumerate}
                \item \begin{verbatim}ts status
                \end{verbatim}
                \item Erwartet: \begin{verbatim}daemon is not running
                \end{verbatim}
                \item \begin{verbatim}ts run
                \end{verbatim}
                \item \begin{verbatim}ts status
                \end{verbatim}
                \item Erwartet: \begin{verbatim}daemon is running
                \end{verbatim}
                \item \begin{verbatim}ts kill
                \end{verbatim}
                \item \begin{verbatim}ts status
                \end{verbatim}
                \item Erwartet: \begin{verbatim}daemon is not running
                \end{verbatim}
            \end{enumerate} \\ \hline
            \textbf{Erwartetes Ergebnis} & Daemon kann gestartet und gestoppt werden. \\ \hline
        \end{tabular}
        \caption{Manueller End-2-End Test E2E-001}\label{tab:e2e-1}
    \end{table}

    \clearpage

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID}                  & E2E-002                             \\ \hline
            \textbf{Beschreibung}        & Autostart                           \\ \hline
            \textbf{Vorbedingungen} &
            \begin{itemize}
                \item Autostart Konfiguration gem.\ Installationshandbuch
            \end{itemize} \\ \hline
            \textbf{Ablauf} &
            \begin{enumerate}
                \item System neustarten
                \item \begin{verbatim}ts status
                \end{verbatim}
                \item Erwartet: \begin{verbatim}daemon is running
                \end{verbatim}
            \end{enumerate} \\ \hline
            \textbf{Erwartetes Ergebnis} & Daemon wird via Autostart gesartet. \\ \hline
        \end{tabular}
        \caption{Manueller End-2-End Test E2E-002}\label{tab:e2e-2}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID}                  & E2E-003                                                \\ \hline
            \textbf{Beschreibung}        & Inspect                                                \\ \hline
            \textbf{Vorbedingungen} &
            \begin{itemize}
                \item OPENAI\_API\_KEY Umgebungsvariable gesetzt gem.\ Installationshandbuch
                \item Daemon läuft
                \item Beispiel-Datei unter [PFAD] vorhanden
            \end{itemize} \\ \hline
            \textbf{Ablauf} &
            \begin{enumerate}
                \item \begin{verbatim}ts inspect [PFAD]
                \end{verbatim}
                \item Erwartet:
                \begin{verbatim}
Intended use:
The file ...

Assessment:
...

Recommended to Wipe:
...

Additional recommendations:
...
                \end{verbatim}
            \end{enumerate} \\ \hline
            \textbf{Erwartetes Ergebnis} & Einschätzung und Empfehlung von der KI wird angezeigt. \\ \hline
        \end{tabular}
        \caption{Manueller End-2-End Test E2E-003}\label{tab:e2e-3}
    \end{table}

    \clearpage

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID}                  & E2E-004                                                                         \\ \hline
            \textbf{Beschreibung}        & Pfad zum Überwachen hinzufügen und entfernen                                    \\ \hline
            \textbf{Vorbedingungen} &
            \begin{itemize}
                \item Daemon läuft
                \item  Der [PFAD] wurde noch nicht hinzugefügt
            \end{itemize} \\ \hline
            \textbf{Ablauf} &
            \begin{enumerate}
                \item \begin{verbatim}ts monitor add [PFAD]
                \end{verbatim}
                \item Erwartet: \begin{verbatim}Successfully added [PFAD]
to the monitoring database.
                \end{verbatim}
                \item \begin{verbatim}ts monitor list
                \end{verbatim}
                \item Erwartet: Der hinzugefügte Pfad wird aufgelistet.
                [ID] des Pfades notieren.
                \item \begin{verbatim}ts monitor remove [ID]
                \end{verbatim}
                \item Erwartet: \begin{verbatim}Successfully removed path with ID [ID]
from the monitoring database.
                \end{verbatim}
                \item \begin{verbatim}ts monitor list
                \end{verbatim}
                \item Erwartet: Der gelöschte Pfad wird nicht mehr aufgelistet.
            \end{enumerate} \\ \hline
            \textbf{Erwartetes Ergebnis} & Ein Pfad kann ohne Fehler hinzugefügt und anschliessend wieder entfernt werden. \\ \hline
        \end{tabular}
        \caption{Manueller End-2-End Test E2E-004}\label{tab:e2e-4}
    \end{table}

    \clearpage

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID}                  & E2E-005                                                        \\ \hline
            \textbf{Beschreibung}        & Pfad zum Überwachen mit Mode und ohne Unterordner hinzufügen.  \\ \hline
            \textbf{Vorbedingungen} &
            \begin{itemize}
                \item Daemon läuft
                \item  Der [PFAD] wurde noch nicht hinzugefügt
            \end{itemize} \\ \hline
            \textbf{Ablauf} &
            \begin{enumerate}
                \item \begin{verbatim}ts monitor add [PFAD]
--mode log --no-subdirs
                \end{verbatim}
                \item Erwartet: \begin{verbatim}Successfully added [PFAD] to the
monitoring database.
                \end{verbatim}
                \item \begin{verbatim}ts monitor list
                \end{verbatim}
                \item Erwartet: Pfad wird mit mode=LOG und no-subdirs=true aufgelistet.
            \end{enumerate} \\ \hline
            \textbf{Erwartetes Ergebnis} & Ein Pfad kann mit den gewünschten Optionen hinzugefügt werden. \\ \hline
        \end{tabular}
        \caption{Manueller End-2-End Test E2E-005}\label{tab:e2e-5}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID}                  & E2E-006                                                               \\ \hline
            \textbf{Beschreibung}        & Pfad zum Überwachen mit Regex-Pattern hinzufügen.                     \\ \hline
            \textbf{Vorbedingungen} &
            \begin{itemize}
                \item Daemon läuft
                \item  Der [PFAD] wurde noch nicht hinzugefügt
            \end{itemize} \\ \hline
            \textbf{Ablauf} &
            \begin{enumerate}
                \item \begin{verbatim}ts monitor add [PFAD] --mode pattern
--pattern ^ts_.*_ts$
                \end{verbatim}
                \item Erwartet: \begin{verbatim}Successfully added [PFAD] to the
monitoring database.
                \end{verbatim}
                \item \begin{verbatim}ts monitor list
                \end{verbatim}
                \item Erwartet: Pfad wird mit pattern=\begin{verbatim}^ts_.*_ts$
                \end{verbatim} aufgelistet.
            \end{enumerate} \\ \hline
            \textbf{Erwartetes Ergebnis} & Ein Pfad kann mit einem gewünschten Regex-Pattern hinzugefügt werden. \\ \hline
        \end{tabular}
        \caption{Manueller End-2-End Test E2E-006}\label{tab:e2e-6}
    \end{table}

    \clearpage

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID} & E2E-007 \\ \hline
            \textbf{Beschreibung} & Snapshots generieren lassen und vergleichen. \\ \hline
            \textbf{Vorbedingungen} &
            \begin{itemize}
                \item Daemon läuft
                \item Der [PFAD] wurde noch nicht hinzugefügt.
                (Empfohlen: ein nicht zu tiefer Pfad, damit die Snapshots schneller generiert werden)
            \end{itemize} \\ \hline
            \textbf{Ablauf} &
            \begin{enumerate}
                \item \begin{verbatim}ts monitor add [PFAD] && ts monitor list
                \end{verbatim}
                \item Erwartet: Auflistung des zu überwachenden Pfads, sowie dessen [ID].
                \item \begin{verbatim}ts kill && ts run
                \end{verbatim}
                \item Warten bis Snapshot in Datenbank vorhanden ist.
                Mit nachfolgendem Schritt überprüfen.
                \item \begin{verbatim}ts snapshots list [ID]
                \end{verbatim}
                \item Erwartet: Liste mit genau 1 Snapshot.
                \item Eine Datei test.log in [PFAD] erstellen und mit Inhalt füllen.
                \item \begin{verbatim}ts kill && ts run
                \end{verbatim}
                \item Warten bis zweiter Snapshot in Datenbank vorhanden ist.
                Mit nachfolgendem Schritt überprüfen.
                \item \begin{verbatim}ts snapshots list [ID]
                \end{verbatim}
                \item Erwartet: Liste mit genau 2 Snapshots.
                \item \begin{verbatim}ts snapshots compare [ID]
                \end{verbatim}
                \item Erwartet: Unterschied in der Datei test.log wird aufgelistet.
                \item \begin{verbatim}ts kill && ts run
                \end{verbatim}
                \item Warten bis in Datenbank genau 3 Snapshots vorhanden sind.
                (siehe oben)
                \item \begin{verbatim}ts kill && ts run
                \end{verbatim}
                \item Warten bis in Datenbank genau 4 Snapshots vorhanden sind.
                (siehe oben)
                \item Den Inhalte der Datei test.log ändern.
                \item \begin{verbatim}ts kill && ts run
                \end{verbatim}
                \item Warten bis in Datenbank genau 5 Snapshots vorhanden sind.
                (siehe oben)
                \item \begin{verbatim}ts snapshots compare [ID]
                \end{verbatim}
                \item Erwartet: Unterschied in der Datei test.log wird aufgelistet.
                \item test.log löschen.
                \item \begin{verbatim}ts kill && ts run
                \end{verbatim}
                \item Warten bis in Datenbank genau 6 Snapshots vorhanden sind.
                \item \begin{verbatim}ts snapshots compare [ID]
                \end{verbatim}
                \item Erwartet: Löschung der Datei test.log wird aufgelistet.
            \end{enumerate} \\ \hline
            \textbf{Erwartetes Ergebnis} & Snapshots werden generiert und drei verschiedenen Zeitintervalle verglichen.
            Erstellung, Änderung und Löschung einer Datei werden erkannt. \\ \hline
        \end{tabular}
        \caption{Manueller End-2-End Test E2E-007}\label{tab:e2e-7}
    \end{table}

    \clearpage

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID}                  & E2E-008                                            \\ \hline
            \textbf{Beschreibung}        & Search (Cache- und Log-Dateien)                    \\ \hline
            \textbf{Vorbedingungen} &
            \begin{itemize}
                \item Daemon läuft
                \item Beispiel-Verzeichnis unter [PFAD] vorhanden
            \end{itemize} \\ \hline
            \textbf{Ablauf} &
            \begin{enumerate}
                \item \begin{verbatim}ts search [PFAD]
                \end{verbatim}
                \item Erwartet: Auflistung der Inhalte unter [PFAD] welche \("\)cache\("\) oder \("\)log\("\) enthalten.
            \end{enumerate} \\ \hline
            \textbf{Erwartetes Ergebnis} & Auflistung von Dateiinhalten in einem Verzeichnis. \\ \hline
        \end{tabular}
        \caption{Manueller End-2-End Test E2E-008}\label{tab:e2e-8}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|c|p{10cm}|}
            \hline
            \textbf{ID}                  & E2E-009                          \\ \hline
            \textbf{Beschreibung}        & Leeren und Löschen einer Datei   \\ \hline
            \textbf{Vorbedingungen} &
            \begin{itemize}
                \item Datei unter [PFAD] ist nicht geschützt. (z.B. durch Berechtigungen)
                \item Daemon läuft
            \end{itemize} \\ \hline
            \textbf{Ablauf} &
            \begin{enumerate}
                \item \begin{verbatim}ts wipe [PFAD]
                \end{verbatim}
                \item Erwartet: \begin{verbatim}Successfully cleared file.
                \end{verbatim}
                \item Erwartet: Datei wurde geleert
                \item \begin{verbatim}ts wipe [PFAD] --remove
                \end{verbatim}
                \item Erwartet: \begin{verbatim}Successfully removed file.
                \end{verbatim}
                \item Erwartet: Datei wurde gelöscht
            \end{enumerate} \\ \hline
            \textbf{Erwartetes Ergebnis} & Datei wird geleert und gelöscht. \\ \hline
        \end{tabular}
        \caption{Manueller End-2-End Test E2E-009}\label{tab:e2e-9}
    \end{table}

    \clearpage

    \subsection{Testergebnisse}
    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.4cm}
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Datum} & \textbf{Betriebssystem} & \textbf{Testfall} & \textbf{Ergebnis} \\ \hline
            26.12.2024     & Windows 11--10.0        & E2E-001           & Erfolgreich       \\ \hline
            26.12.2024     & Linux 6.1.0-28          & E2E-001           & Erfolgreich       \\ \hline
            26.12.2024     & macOS Sequoia 15.2      & E2E-001           & Erfolgreich       \\ \hline
            26.12.2024     & Windows 11--10.0        & E2E-002           & Erfolgreich       \\ \hline
            26.12.2024     & Linux 6.1.0-28          & E2E-002           & Erfolgreich       \\ \hline
            26.12.2024     & macOS Sequoia 15.2      & E2E-002           & Erfolgreich       \\ \hline
            26.12.2024     & Windows 11--10.0        & E2E-003           & Erfolgreich       \\ \hline
            26.12.2024     & Linux 6.1.0-28          & E2E-003           & Erfolgreich       \\ \hline
            26.12.2024     & macOS Sequoia 15.2      & E2E-003           & Erfolgreich       \\ \hline
            26.12.2024     & Windows 11--10.0        & E2E-004           & Erfolgreich       \\ \hline
            26.12.2024     & Linux 6.1.0-28          & E2E-004           & Erfolgreich       \\ \hline
            26.12.2024     & macOS Sequoia 15.2      & E2E-004           & Erfolgreich       \\ \hline
            26.12.2024     & Windows 11--10.0        & E2E-005           & Erfolgreich       \\ \hline
            26.12.2024     & Linux 6.1.0-28          & E2E-005           & Erfolgreich       \\ \hline
            26.12.2024     & macOS Sequoia 15.2      & E2E-005           & Erfolgreich       \\ \hline
            26.12.2024     & Windows 11--10.0        & E2E-006           & Erfolgreich       \\ \hline
            26.12.2024     & Linux 6.1.0-28          & E2E-006           & Erfolgreich       \\ \hline
            26.12.2024     & macOS Sequoia 15.2      & E2E-006           & Erfolgreich       \\ \hline
            26.12.2024     & Windows 11--10.0        & E2E-007           & Erfolgreich       \\ \hline
            26.12.2024     & Linux 6.1.0-28          & E2E-007           & Erfolgreich       \\ \hline
            26.12.2024     & macOS Sequoia 15.2      & E2E-007           & Erfolgreich       \\ \hline
            26.12.2024     & Windows 11--10.0        & E2E-008           & Erfolgreich       \\ \hline
            26.12.2024     & Linux 6.1.0-28          & E2E-008           & Erfolgreich       \\ \hline
            26.12.2024     & macOS Sequoia 15.2      & E2E-008           & Erfolgreich       \\ \hline
            26.12.2024     & Windows 11--10.0        & E2E-009           & Erfolgreich       \\ \hline
            26.12.2024     & Linux 6.1.0-28          & E2E-009           & Erfolgreich       \\ \hline
            26.12.2024     & macOS Sequoia 15.2      & E2E-009           & Erfolgreich       \\ \hline

        \end{tabular}
        \caption{Manuelle End-2-End Testergebnisse}\label{tab:e2e-results}
    \end{table}


    \clearpage


    \section{Messungen (Performanztests)}\label{sec:performanztests}
    Um eine Aussage über die Performanz unseres Systems zu machen, haben wir einige Performanztests durchgeführt.
    Diese dienen lediglich als Indikator und sind nicht repräsentativ für alle möglichen Szenarien.
    Es werden nur Kernfunktionen getestet, die Performanz kritisch sein könnten.

    \subsection{Suchfunktion}\label{subsec:testduchfuhrung}
    Es wird im Modus FULL (Cache- und Logdateien) im spezifizierten Pfad nach Dateien gesucht.

    \subsubsection{Verwendete Umgebungsangaben und Metriken}\label{subsubsec:search-perftest-metrics-title}
    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|p{7cm}|p{7cm}|}
            \hline
            \textbf{System}                                            & Betriebssystem und Architektur                                                  \\ \hline
            \textbf{Pfad}                                              & Verzeichnis, in dem gesucht wird                                                \\ \hline
            \textbf{Anz. Dateien im Pfad}                              & Anzahl Dateien im Pfad (mit allen Unterverzeichnissen)                          \\ \hline
            \textbf{Anz. Verzeichnisse im Pfad}                        & Anzahl Unterverzeichnisse                                                       \\ \hline
            \textbf{Anz. Ebenen \newline des Baumes relevanter Knoten} & Anzahl Ebenen im konstruierten Baum aller gefundenen Dateien und Verzeichnissen \\ \hline
            \textbf{Anz. Knoten \newline des Baumes relevanter Knoten} & Anzahl Knoten im konstruierten Baum aller gefundenen Dateien und Verzeichnissen \\ \hline
            \textbf{Gefundene Dateien}                                 & Anzahl Dateien, die gefunden wurden                                             \\ \hline
            \textbf{Dauer (Stichprobenmittel)}                         & Mittelwert der Dauer in Millisekunden aus mehreren Stichproben                  \\ \hline
        \end{tabular}
        \caption{Beschreibung Umgebungsangaben und Metriken Suchfunktion-Performanztest}\label{tab:perf-search-metrics}
    \end{table}

    \newpage

    \subsubsection{Ergebnisse}
    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|p{7cm}|p{5cm}|}
            \hline
            \textbf{System}                                            & Windows 11--10.0 / amd64 \\ \hline
            \textbf{Pfad}                                              & C:\textbackslash Windows \\ \hline
            \textbf{Anz. Dateien im Pfad}                              & 188'428                  \\ \hline
            \textbf{Anz. Verzeichnisse im Pfad}                        & 51'184                   \\ \hline
            \textbf{Anz. Ebenen \newline des Baumes relevanter Knoten} & 14                       \\ \hline
            \textbf{Anz. Knoten \newline des Baumes relevanter Knoten} & 54'682                   \\ \hline
            \textbf{Gefundene Dateien}                                 & 3'455                    \\ \hline
            \textbf{Dauer (Stichprobenmittel)}                         & 8'800ms                  \\ \hline
        \end{tabular}
        \caption{Performanztest Suche WIN-1}\label{tab:perf-search-win-1}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|p{7cm}|p{5cm}|}
            \hline
            \textbf{System}                                            & Windows 11--10.0 / amd64       \\ \hline
            \textbf{Pfad}                                              & C:\textbackslash Program Files \\ \hline
            \textbf{Anz. Dateien im Pfad}                              & 66'386                         \\ \hline
            \textbf{Anz. Verzeichnisse im Pfad}                        & 8'925                          \\ \hline
            \textbf{Anz. Ebenen \newline des Baumes relevanter Knoten} & 20                             \\ \hline
            \textbf{Anz. Knoten \newline des Baumes relevanter Knoten} & 10'109                         \\ \hline
            \textbf{Gefundene Dateien}                                 & 1'183                          \\ \hline
            \textbf{Dauer (Stichprobenmittel)}                         & 800ms                          \\ \hline
        \end{tabular}
        \caption{Performanztest Suche WIN-2}\label{tab:perf-search-win-2}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|p{7cm}|p{5cm}|}
            \hline
            \textbf{System}                                            & macOS Sequoia 15.2 / aarch64 \\ \hline
            \textbf{Pfad}                                              & /Library/Logs/               \\ \hline
            \textbf{Anz. Dateien im Pfad}                              & 229                          \\ \hline
            \textbf{Anz. Verzeichnisse im Pfad}                        & 89                           \\ \hline
            \textbf{Anz. Ebenen \newline des Baumes relevanter Knoten} & 9                            \\ \hline
            \textbf{Anz. Knoten \newline des Baumes relevanter Knoten} & 120                          \\ \hline
            \textbf{Gefundene Dateien}                                 & 31                           \\ \hline
            \textbf{Dauer (Stichprobenmittel)}                         & 6.6ms                        \\ \hline
        \end{tabular}
        \caption{Performanztest Suche MAC-1}\label{tab:perf-search-mac-1}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|p{7cm}|p{5cm}|}
            \hline
            \textbf{System}                                            & macOS Sequoia 15.2 / aarch64 \\ \hline
            \textbf{Pfad}                                              & /Library/Caches/             \\ \hline
            \textbf{Anz. Dateien im Pfad}                              & 677                          \\ \hline
            \textbf{Anz. Verzeichnisse im Pfad}                        & 8                            \\ \hline
            \textbf{Anz. Ebenen \newline des Baumes relevanter Knoten} & 3                            \\ \hline
            \textbf{Anz. Knoten \newline des Baumes relevanter Knoten} & 6                            \\ \hline
            \textbf{Gefundene Dateien}                                 & 0                            \\ \hline
            \textbf{Dauer (Stichprobenmittel)}                         & 0.6ms                        \\ \hline
        \end{tabular}
        \caption{Performanztest Suche MAC-2}\label{tab:perf-search-mac-2}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|p{7cm}|p{5cm}|}
            \hline
            \textbf{System}                                            & Linux 6.1.0-28 / amd64    \\ \hline
            \textbf{Pfad}                                              & /opt/idea-IU-242.22855.74 \\ \hline
            \textbf{Anz. Dateien im Pfad}                              & 2248                      \\ \hline
            \textbf{Anz. Verzeichnisse im Pfad}                        & 793                       \\ \hline
            \textbf{Anz. Ebenen \newline des Baumes relevanter Knoten} & 10                        \\ \hline
            \textbf{Anz. Knoten \newline des Baumes relevanter Knoten} & 806                       \\ \hline
            \textbf{Gefundene Dateien}                                 & 13                        \\ \hline
            \textbf{Dauer (Stichprobenmittel)}                         & 21ms                      \\ \hline
        \end{tabular}
        \caption{Performanztest Suche LIN-1}\label{tab:perf-search-lin-1}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|p{7cm}|p{5cm}|}
            \hline
            \textbf{System}                                            & Linux 6.1.0-28 / amd64 \\ \hline
            \textbf{Pfad}                                              & /home/luca             \\ \hline
            \textbf{Anz. Dateien im Pfad}                              & 47'3915                \\ \hline
            \textbf{Anz. Verzeichnisse im Pfad}                        & 9'8549                 \\ \hline
            \textbf{Anz. Ebenen \newline des Baumes relevanter Knoten} & 29                     \\ \hline
            \textbf{Anz. Knoten \newline des Baumes relevanter Knoten} & 104'448                \\ \hline
            \textbf{Gefundene Dateien}                                 & 5'429                  \\ \hline
            \textbf{Dauer (Stichprobenmittel)}                         & 2'663ms                \\ \hline
        \end{tabular}
        \caption{Performanztest Suche LIN-2}\label{tab:perf-search-lin-2}
    \end{table}

    \clearpage

    \subsection{Monitoring}\label{subsec:monitoring)}
    Es werden mehrere Pfade über einen längeren Zeitraum (simuliert) überwacht bzw.\ Snapshots erstellt.

    \subsubsection{Verwendete Umgebungsangaben und Metriken}\label{subsubsec:monitoring-perftest-metrics-title}
    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|p{7cm}|p{7cm}|}
            \hline
            \textbf{System}                                                & Betriebssystem und Architektur                                              \\ \hline
            \textbf{Pfade}                                                 & Verzeichnisse, die überwacht werden                                         \\ \hline
            \textbf{Anz. Erstellte Snapshots}                              & Anzahl erstellter Snapshots                                                 \\ \hline
            \textbf{Anz. Erstellte Knoten}                                 & Anzahl erstellter Knoten in der Datenbank                                   \\ \hline
            \textbf{Benötigte Zeit}                                        & Gesamte Zeit, die benötigt wurde, um alle Snapshots zu erstellen            \\ \hline
            \textbf{Durchschnittliche Dauer zum Erstellen eines Snapshots} & Durchschnittliche Dauer, die benötigt wurde, um einen Snapshot zu erstellen \\ \hline
        \end{tabular}
        \caption{Beschreibung Umgebungsangaben und Metriken Monitoring-Performanztest}\label{tab:monitoring-perftest-metrics}
    \end{table}

    \subsubsection{Ergebnisse}
    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|p{5cm}|p{10cm}|}
            \hline
            \textbf{System}                                                & Windows 11--10.0 / amd64 \\ \hline
            \textbf{Pfade} &
            \begin{itemize}
                \item C:\textbackslash Users\textbackslash Luca\textbackslash AppData\textbackslash Roaming\textbackslash discord\textbackslash Cache
                \item C:\textbackslash Users\textbackslash Luca\textbackslash AppData\textbackslash Roaming\textbackslash discord\textbackslash logs
                \item C:\textbackslash Users\textbackslash Luca\textbackslash AppData\textbackslash Roaming\textbackslash Docker Desktop\textbackslash Cache
                \item C:\textbackslash Users\textbackslash Luca\textbackslash AppData\textbackslash Roaming\textbackslash Microsoft
                \item C:\textbackslash Users\textbackslash Luca\textbackslash AppData\textbackslash Roaming\textbackslash NVIDIA
                \item C:\textbackslash ProgramData\textbackslash ASUS
                \item C:\textbackslash ProgramData\textbackslash Package Cache
                \item C:\textbackslash ProgramData\textbackslash Corsair
                \item C:\textbackslash ProgramData\textbackslash NVIDIA Corporation
                \item C:\textbackslash ProgramData\textbackslash LGHUB
            \end{itemize}
            \\ \hline
            \textbf{Anz. Erstellte Snapshots}                              & 7'200                    \\ \hline
            \textbf{Anz. Erstellte Knoten}                                 & 583'920                  \\ \hline
            \textbf{Benötigte Zeit}                                        & 8min                     \\ \hline
            \textbf{Durchschnittliche Dauer zum Erstellen eines Snapshots} & 670ms                    \\ \hline
        \end{tabular}
        \caption{Performanztest Monitoring WIN}\label{tab:perf-monitoring-win}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|p{5cm}|p{10cm}|}
            \hline
            \textbf{System}                                                & macOS Sequoia 15.2 / aarch64 \\ \hline
            \textbf{Pfade} &
            \begin{itemize}
                \item /Library/Logs/
                \item /Library/Caches/
                \item /Library/Google
                \item /Library/Google
                \item /Library/Apple
                \item /Library/OSAnalytics
                \item /Library/Filesystems
                \item /Library/Bluetooth
                \item /Users/janicscherer/IdeaProjects
                \item /Users/janicscherer/bin
                \item /tmp
            \end{itemize}
            \\ \hline
            \textbf{Anz. Erstellte Snapshots}                              & 7'200                        \\ \hline
            \textbf{Anz. Erstellte Knoten}                                 & 9'079'920                    \\ \hline
            \textbf{Benötigte Zeit}                                        & 10min                        \\ \hline
            \textbf{Durchschnittliche Dauer zum Erstellen eines Snapshots} & 914ms                        \\ \hline
        \end{tabular}
        \caption{Performanztest Monitoring MAC}\label{tab:perf-monitoring-mac}
    \end{table}

    \begin{table}[h!]
        \centering
        \setlength{\leftmargini}{0.8cm}
        \begin{tabular}{|p{5cm}|p{10cm}|}
            \hline
            \textbf{System}                                                & Linux 6.1.0-28 / amd64 \\ \hline
            \textbf{Pfade} &
            \begin{itemize}
                \item /home/luca/tracesentry-1.0.2
                \item /opt/idea-IU-242.22855.74
                \item /opt/vivaldi
                \item /tmp
                \item /etc
                \item /usr/local
                \item /usr/share/vim
                \item /dev
                \item /opt/az/lib/python3.12/email
                \item /opt/android-studio
            \end{itemize}
            \\ \hline
            \textbf{Anz. Erstellte Snapshots}                              & 7'200                  \\ \hline
            \textbf{Anz. Erstellte Knoten}                                 & 1'717'920              \\ \hline
            \textbf{Benötigte Zeit}                                        & 2min                   \\ \hline
            \textbf{Durchschnittliche Dauer zum Erstellen eines Snapshots} & 173ms                  \\ \hline
        \end{tabular}
        \caption{Performanztest Monitoring LIN}\label{tab:perf-monitoring-lin}
    \end{table}


    \section{KI Case Study}\label{sec:ki-case-study}


    \chapter{Bereitstellung/Integration}

    \begin{figure}[h]
        \centering
        \includegraphics[width=1\textwidth]{assets/DeplDiagram}
        \caption{UML Deploymentdiagramm}
        \label{fig:depl-diag}
    \end{figure}

    Das ganze System befindet sich während der Laufzeit auf dem Host-Gerät des Anwenders.
    Dazu werden zwei separate Jar-Dateien ausgeliefert.
    Die Erste sollte bereits beim Start des Geräts ausgeführt werden und die JVM für den Daemon starten.
    Dieser startet einen Webservice, der REST-Schnittstellen für die Steuerung des Daemons anbietet.
    Dieser REST-Service kommuniziert ausserdem über JDBC mit einem RDBMS, welches in Form von einer einzigen Datei (SQLite)
    in der Daemon-Applikation embedded ist.

    Das zweite Jar sollte dann manuell vom Anwender gestartet werden sobald er Funktionen des Daemons ausführen möchte.
    Dieses Jar startet wiederum eine zweite JVM, welche ein CLI für den Anwender mit bestimmten Kommandos zur Verfügung stellt.
    Diese CLI sendet dann über HTTP die entsprechenden Anfragen an den Daemon, die zur Erfüllung der Anweisungen des Anwenders führen.


    \section{Lizenzierung}


    \section{Installationshandbuch \& Skript}
    In diesem Kapitel sind die Installationsanleitungen für alle unterstützten Plattformen beschrieben.

    Eine Installation der Java Laufzeitumgebung (JRE) wird für die Installation vorrausgesetzt.

    \subsection{Linux}\label{subsec:linux}
    \begin{enumerate}
        \item Durchsuchen Sie das neueste Artefakt, das vom Hauptbranch dieses Repositorys erstellt wurde, und laden Sie die Datei
        \texttt{target/tracesentry-\textless{}version\textgreater{}-submission.zip} auf Ihren Computer herunter.
        \item Entpacken Sie das Archiv in Ihr gewünschtes Installationsverzeichnis für TraceSentry.
        \item Definieren Sie die folgenden Umgebungsvariablen in der Datei \texttt{/etc/environment}:
        \begin{lstlisting}[label={lst:lstlisting-unix-1}]
JAVA_HOME=<absoluter Pfad zum JDK-Ordner>
TRACE_SENTRY_DIR=<absoluter Pfad zum Installationsverzeichnis>
        \end{lstlisting}
        Und fügen Sie die Variable \texttt{TRACE\_SENTRY\_DIR} am Ende der Datei \texttt{/etc/profile} zum \texttt{PATH} hinzu:
        \begin{lstlisting}[label={lst:lstlisting-unix-2}]
PATH=$PATH:$TRACE_SENTRY_DIR
        \end{lstlisting}
        \item Wenn Sie die Inspektionsfunktion nutzen möchten, erstellen Sie einen OpenAI-API-Schlüssel, indem Sie den Anweisungen unter \url{https://platform.openai.com/settings/organization/api-keys} folgen.
        Fügen Sie Guthaben zu Ihrem Konto hinzu, um die OpenAI-API nutzen zu können: \url{https://platform.openai.com/settings/organization/billing/overview}.
        Setzen Sie anschließend den generierten API-Schlüssel als Umgebungsvariable am Ende der Datei \texttt{/etc/profile}:
        \begin{lstlisting}[label={lst:lstlisting-unix-3}]
export OPENAI_API_KEY=<generierter API-Schlüssel>
        \end{lstlisting}
        Sollten Sie diesen Teil überspringen, werden Sie keinen Zugriff auf die Inspektionsfunktion haben.
        \item Wenn der Daemon bei jedem Systemstart automatisch im Hintergrund gestartet werden soll, können Sie Folgendes in einem Terminal ausführen:
        \begin{lstlisting}[label={lst:lstlisting-unix-4}]
crontab -e
// Fügen Sie die folgende Zeile am Ende der geöffneten Datei hinzu
@reboot PATH=$JAVA_HOME/bin:$PATH $TRACE_SENTRY_DIR/ts run
        \end{lstlisting}
        Speichern Sie dann die Datei.
        \item Nach einem Systemneustart sind Sie bereit, TraceSentry zu verwenden.
    \end{enumerate}

    \subsection{Windows}
    \begin{enumerate}
        \item Durchsuchen Sie das neueste Artefakt, das vom Hauptbranch dieses Repositorys erstellt wurde, und laden Sie die Datei
        \texttt{target/tracesentry-\textless{}version\textgreater{}-submission.zip} auf Ihren Computer herunter.
        \item Entpacken Sie das Archiv in Ihr gewünschtes Installationsverzeichnis für TraceSentry.
        \item Setzen Sie die Umgebungsvariable \texttt{TRACE\_SENTRY\_DIR} via Systemsteuerung oder via PowerShell:
        \begin{lstlisting}[label={lst:lstlisting-windows-1}]
[System.Environment]::SetEnvironmentVariable("TRACE_SENTRY_DIR", "<absoluter Pfad zum Installationsverzeichnis>","User")
        \end{lstlisting}
        \item Damit die CLI korrekt funktioniert, fügen Sie das Installationsverzeichnis zum \texttt{PATH} hinzu:
        \begin{lstlisting}[label={lst:lstlisting-windows-2}]
$currentPath = [System.Environment]::GetEnvironmentVariable("Path", "User")
[System.Environment]::SetEnvironmentVariable("Path", "$currentPath;<absoluter Pfad zum Installationsverzeichnis>","User")
        \end{lstlisting}
        \item Wenn Sie die Inspektionsfunktion nutzen möchten, erstellen Sie einen OpenAI-API-Schlüssel, indem Sie den Anweisungen unter \url{https://platform.openai.com/settings/organization/api-keys} folgen.
        Fügen Sie Guthaben zu Ihrem Konto hinzu, um die OpenAI-API nutzen zu können: \url{https://platform.openai.com/settings/organization/billing/overview}.
        Setzen Sie anschließend den generierten API-Schlüssel als Umgebungsvariable via PowerShell:
        \begin{lstlisting}[label={lst:lstlisting-windows-3}]
[System.Environment]::SetEnvironmentVariable("OPENAI_API_KEY", "<generierter API-Schluessel>","User")
        \end{lstlisting}
        Sollten Sie diesen Teil überspringen, werden Sie keinen Zugriff auf die Inspektionsfunktion haben.
        \item Wenn der Daemon bei jedem Systemstart automatisch im Hintergrund gestartet werden soll, muss die Datei \texttt{ts-daemon.bat} vom Installationsverzeichnis in den Autostart-Ordner kopiert werden:
        \begin{lstlisting}[label={lst:lstlisting-windows-4}]
Copy-Item "$env:TRACE_SENTRY_DIR\ts-daemon.bat" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup"
        \end{lstlisting}
        Beim nächsten Systemstart wird der Daemon automatisch gestartet.
        Beim ersten Start kann eine Sicherheitswarnung erscheinen, in der Sie eine Checkbox deaktivieren müssen, damit diese in Zukunft nicht mehr erscheint.
        \item Starten Sie das Terminal neu, und Sie sind bereit, TraceSentry zu verwenden.
    \end{enumerate}

    \clearpage

    \subsection{macOS}\label{subsec:macos}
    Der Einfachheit halber werden hier ausschliesslich Konfigurationen im \texttt{.zprofile} File benützt.
    Die nachfolgenden Befehle schreiben die Konfigurationen direkt in die Datei.
    \begin{enumerate}
        \item Durchsuchen Sie das neueste Artefakt, das vom Hauptbranch dieses Repositorys erstellt wurde, und laden Sie die Datei
        \texttt{target/tracesentry-\textless{}version\textgreater{}-submission.zip} auf Ihren Computer herunter.
        \item Entpacken Sie das Archiv in Ihr gewünschtes Installationsverzeichnis für TraceSentry.
        \item Setzen Sie die Umgebungsvariable \texttt{TRACE\_SENTRY\_DIR} im \texttt{.zprofile} File (befindet sich in Ihrem Home-Verzeichnis):
        \begin{lstlisting}[label={lst:lstlisting-mac-1}]
echo '\n# Added for TraceSentry' >> ~/.zprofile
echo export TRACE_SENTRY_DIR="<absoluter Pfad zum Installationsverzeichnis>" >> ~/.zprofile
        \end{lstlisting}
        \item Damit die CLI korrekt funktioniert, fügen Sie im \texttt{.zprofile} File das Installationsverzeichnis zum \texttt{PATH} hinzu:
        \begin{lstlisting}[label={lst:lstlisting-mac-2}]
echo export PATH="\$TRACE_SENTRY_DIR:\$PATH" >> ~/.zprofile
        \end{lstlisting}
        \item Wenn Sie die Inspektionsfunktion nutzen möchten, erstellen Sie einen OpenAI-API-Schlüssel, indem Sie den Anweisungen unter \url{https://platform.openai.com/settings/organization/api-keys} folgen.
        Fügen Sie Guthaben zu Ihrem Konto hinzu, um die OpenAI-API nutzen zu können: \url{https://platform.openai.com/settings/organization/billing/overview}.
        Setzen Sie anschließend den generierten API-Schlüssel als Umgebungsvariable im \texttt{.zprofile} File:
        \begin{lstlisting}[label={lst:lstlisting-mac-3}]
echo export OPENAI_API_KEY=<generierter API-Schluessel> >> ~/.zprofile
        \end{lstlisting}
        Sollten Sie diesen Teil überspringen, werden Sie keinen Zugriff auf die Inspektionsfunktion haben.
        \item Wenn der Daemon bei jedem Systemstart automatisch im Hintergrund gestartet werden soll, passen Sie das \texttt{.zprofile} File in ihrem Home-Verzeichnis wie folgt an:
        \begin{lstlisting}[label={lst:lstlisting-mac-4}]
echo ts run >> ~/.zprofile
        \end{lstlisting}
        Dies wird als pragmatische Lösung empfohlen.
        Alternativ können Sie auch \textit{launchd} verwenden.\footnote{\url{https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html}}
        \item Starten Sie das Terminal neu, dadurch wird der Daemon automatisch gestartet (sofern Sie Schritt 6 befolgt haben), und Sie sind bereit, TraceSentry zu verwenden.
    \end{enumerate}

    \clearpage


    \section{Benutzerhandbuch}
    \label{sec:user-manual}


    \chapter{Fazit}


    \section{Diskussion}

    \subsection{Ausblick auf die Zukunft}


    \section{Zusammenfassung}


    \section{Zukünftige Arbeiten}\label{sec:zukunftigearbeiten}
    \url{https://doi.org/10.1145/3664811}


    \chapter{Glossar}


    \chapter{Index}


    \chapter{Bibliografie}


    \chapter{Anhang}


    \section{Facsimile der Projektbeschreibung}


    \section{Erklärung zur Urheberschaft}

\end{document}
